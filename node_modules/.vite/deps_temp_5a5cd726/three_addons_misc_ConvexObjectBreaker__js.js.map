{
  "version": 3,
  "sources": ["../../three/examples/jsm/math/ConvexHull.js", "../../three/examples/jsm/geometries/ConvexGeometry.js", "../../three/examples/jsm/misc/ConvexObjectBreaker.js"],
  "sourcesContent": ["import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n\n/**\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n */\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\n\nclass ConvexHull {\n\n\tconstructor() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\t// The algorithm needs at least four points.\n\n\t\tif ( points.length >= 4 ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.compute();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object ) {\n\n\t\tconst points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tconst geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tconst attribute = geometry.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst point = new Vector3();\n\n\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\tconst faces = this.faces;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tintersectRay( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n\t\tconst faces = this.faces;\n\n\t\tlet tNear = - Infinity;\n\t\tlet tFar = Infinity;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tconst vN = face.distanceToPoint( ray.origin );\n\t\t\tconst vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\tconst t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t// plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, _v1 ) !== null;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t}\n\n\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\taddVertexToFace( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\tremoveVertexFromFace( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t}\n\n\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list\n\n\tremoveAllVerticesFromFace( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tconst start = face.outside;\n\t\t\tlet end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t}\n\n\t// Removes all the visible vertices that 'face' is able to see\n\n\tdeleteFaceVertices( face, absorbingFace ) {\n\n\t\tconst faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tlet vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\t\tconst distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\tresolveUnassignedPoints( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tlet vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\tlet maxDistance = this.tolerance;\n\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tconst face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tconst distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Computes the extremes of a simplex which will be the initial hull\n\n\tcomputeExtremes() {\n\n\t\tconst min = new Vector3();\n\t\tconst max = new Vector3();\n\n\t\tconst minVertices = [];\n\t\tconst maxVertices = [];\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tconst point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t}\n\n\t// Computes the initial simplex assigning to its faces all the points\n\t// that are candidates to form part of the hull\n\n\tcomputeInitialHull() {\n\n\t\tconst vertices = this.vertices;\n\t\tconst extremes = this.computeExtremes();\n\t\tconst min = extremes.min;\n\t\tconst max = extremes.max;\n\n\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t// (max.x - min.x)\n\t\t// (max.y - min.y)\n\t\t// (max.z - min.z)\n\n\t\tlet maxDistance = 0;\n\t\tlet index = 0;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tindex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst v0 = min[ index ];\n\t\tconst v1 = max[ index ];\n\t\tlet v2;\n\t\tlet v3;\n\n\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\tmaxDistance = 0;\n\t\t_line3.set( v0.point, v1.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t_line3.closestPointToPoint( vertex.point, true, _closestPoint );\n\n\t\t\t\tconst distance = _closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\tmaxDistance = - 1;\n\t\t_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\tconst distance = Math.abs( _plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst faces = [];\n\n\t\tif ( _plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// the initial hull is the tetrahedron\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t}\n\n\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tconst distance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Removes inactive faces\n\n\treindexFaces() {\n\n\t\tconst activeFaces = [];\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t}\n\n\t// Finds the next vertex to create faces with the current hull\n\n\tnextVertexToAdd() {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tlet eyeVertex, maxDistance = 0;\n\n\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\tconst eyeFace = this.assigned.first().face;\n\t\t\tlet vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tconst distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t}\n\n\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t// For an edge to be part of the horizon it must join a face that can see\n\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\tcomputeHorizon( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis.deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tlet edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tconst twinEdge = edge.twin;\n\t\t\tconst oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t}\n\n\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\taddAdjoiningFace( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tconst face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t}\n\n\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t//  horizon opposite face and the face on the left/right\n\n\taddNewFaces( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tlet firstSideEdge = null;\n\t\tlet previousSideEdge = null;\n\n\t\tfor ( let i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tconst horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tconst sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t}\n\n\t// Adds a vertex to the hull\n\n\taddVertexToHull( eyeVertex ) {\n\n\t\tconst horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t}\n\n\tcleanup() {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t}\n\n\tcompute() {\n\n\t\tlet vertex;\n\n\t\tthis.computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis.addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis.reindexFaces();\n\n\t\tthis.cleanup();\n\n\t\treturn this;\n\n\t}\n\n}\n\n//\n\nclass Face {\n\n\tconstructor() {\n\n\t\tthis.normal = new Vector3();\n\t\tthis.midpoint = new Vector3();\n\t\tthis.area = 0;\n\n\t\tthis.constant = 0; // signed distance from face to the origin\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\t\tthis.edge = null;\n\n\t}\n\n\tstatic create( a, b, c ) {\n\n\t\tconst face = new Face();\n\n\t\tconst e0 = new HalfEdge( a, face );\n\t\tconst e1 = new HalfEdge( b, face );\n\t\tconst e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n\tgetEdge( i ) {\n\n\t\tlet edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t}\n\n\tcompute() {\n\n\t\tconst a = this.edge.tail();\n\t\tconst b = this.edge.head();\n\t\tconst c = this.edge.next.head();\n\n\t\t_triangle.set( a.point, b.point, c.point );\n\n\t\t_triangle.getNormal( this.normal );\n\t\t_triangle.getMidpoint( this.midpoint );\n\t\tthis.area = _triangle.getArea();\n\n\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\treturn this;\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n}\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nclass HalfEdge {\n\n\n\tconstructor( vertex, face ) {\n\n\t\tthis.vertex = vertex;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.twin = null;\n\t\tthis.face = face;\n\n\t}\n\n\thead() {\n\n\t\treturn this.vertex;\n\n\t}\n\n\ttail() {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t}\n\n\tlength() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\tlengthSquared() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\tsetTwin( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n}\n\n// A vertex as a double linked list node.\n\nclass VertexNode {\n\n\tconstructor( point ) {\n\n\t\tthis.point = point;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.face = null; // the face that is able to see this vertex\n\n\t}\n\n}\n\n// A double linked list that contains vertex nodes.\n\nclass VertexList {\n\n\tconstructor() {\n\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\n\t}\n\n\tfirst() {\n\n\t\treturn this.head;\n\n\t}\n\n\tlast() {\n\n\t\treturn this.tail;\n\n\t}\n\n\tclear() {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t}\n\n\t// Inserts a vertex before the target vertex\n\n\tinsertBefore( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Inserts a vertex after the target vertex\n\n\tinsertAfter( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Appends a vertex to the end of the linked list\n\n\tappend( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Appends a chain of vertices where 'vertex' is the head.\n\n\tappendChain( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t// Removes a vertex from the linked list\n\n\tremove( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\tremoveSubList( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn this.head === null;\n\n\t}\n\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList };\n", "import {\n\tBufferGeometry,\n\tFloat32BufferAttribute\n} from 'three';\nimport { ConvexHull } from '../math/ConvexHull.js';\n\nclass ConvexGeometry extends BufferGeometry {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\t// buffers\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\n\t\tconst convexHull = new ConvexHull().setFromPoints( points );\n\n\t\t// generate vertices and normals\n\n\t\tconst faces = convexHull.faces;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tlet edge = face.edge;\n\n\t\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n\t\t\tdo {\n\n\t\t\t\tconst point = edge.head().point;\n\n\t\t\t\tvertices.push( point.x, point.y, point.z );\n\t\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== face.edge );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n}\n\nexport { ConvexGeometry };\n", "import {\n\tLine3,\n\tMesh,\n\tPlane,\n\tVector3\n} from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n\n/**\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\n *\n * Usage:\n *\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\n *\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\n *\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\n *\n * Requisites for the object:\n *\n *  - Mesh object must have a buffer geometry and a material\n *\n *  - Vertex normals must be planar (not smoothed)\n *\n *  - The geometry must be convex (this is not checked in the library). You can create convex\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\n *  can also be used.\n *\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\n * Use with caution and read the code when using with other libs.\n *\n * @param {double} minSizeForBreak Min size a debris can have to break.\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\n *\n*/\n\nconst _v1 = new Vector3();\n\nclass ConvexObjectBreaker {\n\n\tconstructor( minSizeForBreak = 1.4, smallDelta = 0.0001 ) {\n\n\t\tthis.minSizeForBreak = minSizeForBreak;\n\t\tthis.smallDelta = smallDelta;\n\n\t\tthis.tempLine1 = new Line3();\n\t\tthis.tempPlane1 = new Plane();\n\t\tthis.tempPlane2 = new Plane();\n\t\tthis.tempPlane_Cut = new Plane();\n\t\tthis.tempCM1 = new Vector3();\n\t\tthis.tempCM2 = new Vector3();\n\t\tthis.tempVector3 = new Vector3();\n\t\tthis.tempVector3_2 = new Vector3();\n\t\tthis.tempVector3_3 = new Vector3();\n\t\tthis.tempVector3_P0 = new Vector3();\n\t\tthis.tempVector3_P1 = new Vector3();\n\t\tthis.tempVector3_P2 = new Vector3();\n\t\tthis.tempVector3_N0 = new Vector3();\n\t\tthis.tempVector3_N1 = new Vector3();\n\t\tthis.tempVector3_AB = new Vector3();\n\t\tthis.tempVector3_CB = new Vector3();\n\t\tthis.tempResultObjects = { object1: null, object2: null };\n\n\t\tthis.segments = [];\n\t\tconst n = 30 * 30;\n\t\tfor ( let i = 0; i < n; i ++ ) this.segments[ i ] = false;\n\n\t}\n\n\tprepareBreakableObject( object, mass, velocity, angularVelocity, breakable ) {\n\n\t\t// object is a Object3d (normally a Mesh), must have a buffer geometry, and it must be convex.\n\t\t// Its material property is propagated to its children (sub-pieces)\n\t\t// mass must be > 0\n\n\t\tconst userData = object.userData;\n\t\tuserData.mass = mass;\n\t\tuserData.velocity = velocity.clone();\n\t\tuserData.angularVelocity = angularVelocity.clone();\n\t\tuserData.breakable = breakable;\n\n\t}\n\n\t/*\n\t * @param {int} maxRadialIterations Iterations for radial cuts.\n\t * @param {int} maxRandomIterations Max random iterations for not-radial cuts\n\t *\n\t * Returns the array of pieces\n\t */\n\tsubdivideByImpact( object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations ) {\n\n\t\tconst debris = [];\n\n\t\tconst tempPlane1 = this.tempPlane1;\n\t\tconst tempPlane2 = this.tempPlane2;\n\n\t\tthis.tempVector3.addVectors( pointOfImpact, normal );\n\t\ttempPlane1.setFromCoplanarPoints( pointOfImpact, object.position, this.tempVector3 );\n\n\t\tconst maxTotalIterations = maxRandomIterations + maxRadialIterations;\n\n\t\tconst scope = this;\n\n\t\tfunction subdivideRadial( subObject, startAngle, endAngle, numIterations ) {\n\n\t\t\tif ( Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations ) {\n\n\t\t\t\tdebris.push( subObject );\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet angle = Math.PI;\n\n\t\t\tif ( numIterations === 0 ) {\n\n\t\t\t\ttempPlane2.normal.copy( tempPlane1.normal );\n\t\t\t\ttempPlane2.constant = tempPlane1.constant;\n\n\t\t\t} else {\n\n\t\t\t\tif ( numIterations <= maxRadialIterations ) {\n\n\t\t\t\t\tangle = ( endAngle - startAngle ) * ( 0.2 + 0.6 * Math.random() ) + startAngle;\n\n\t\t\t\t\t// Rotate tempPlane2 at impact point around normal axis and the angle\n\t\t\t\t\tscope.tempVector3_2.copy( object.position ).sub( pointOfImpact ).applyAxisAngle( normal, angle ).add( pointOfImpact );\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( pointOfImpact, scope.tempVector3, scope.tempVector3_2 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tangle = ( ( 0.5 * ( numIterations & 1 ) ) + 0.2 * ( 2 - Math.random() ) ) * Math.PI;\n\n\t\t\t\t\t// Rotate tempPlane2 at object position around normal axis and the angle\n\t\t\t\t\tscope.tempVector3_2.copy( pointOfImpact ).sub( subObject.position ).applyAxisAngle( normal, angle ).add( subObject.position );\n\t\t\t\t\tscope.tempVector3_3.copy( normal ).add( subObject.position );\n\t\t\t\t\ttempPlane2.setFromCoplanarPoints( subObject.position, scope.tempVector3_3, scope.tempVector3_2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Perform the cut\n\t\t\tscope.cutByPlane( subObject, tempPlane2, scope.tempResultObjects );\n\n\t\t\tconst obj1 = scope.tempResultObjects.object1;\n\t\t\tconst obj2 = scope.tempResultObjects.object2;\n\n\t\t\tif ( obj1 ) {\n\n\t\t\t\tsubdivideRadial( obj1, startAngle, angle, numIterations + 1 );\n\n\t\t\t}\n\n\t\t\tif ( obj2 ) {\n\n\t\t\t\tsubdivideRadial( obj2, angle, endAngle, numIterations + 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tsubdivideRadial( object, 0, 2 * Math.PI, 0 );\n\n\t\treturn debris;\n\n\t}\n\n\tcutByPlane( object, plane, output ) {\n\n\t\t// Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n\t\t// object2 can be null if the plane doesn't cut the object.\n\t\t// object1 can be null only in case of internal error\n\t\t// Returned value is number of pieces, 0 for error.\n\n\t\tconst geometry = object.geometry;\n\t\tconst coords = geometry.attributes.position.array;\n\t\tconst normals = geometry.attributes.normal.array;\n\n\t\tconst numPoints = coords.length / 3;\n\t\tlet numFaces = numPoints / 3;\n\n\t\tlet indices = geometry.getIndex();\n\n\t\tif ( indices ) {\n\n\t\t\tindices = indices.array;\n\t\t\tnumFaces = indices.length / 3;\n\n\t\t}\n\n\t\tfunction getVertexIndex( faceIdx, vert ) {\n\n\t\t\t// vert = 0, 1 or 2.\n\n\t\t\tconst idx = faceIdx * 3 + vert;\n\n\t\t\treturn indices ? indices[ idx ] : idx;\n\n\t\t}\n\n\t\tconst points1 = [];\n\t\tconst points2 = [];\n\n\t\tconst delta = this.smallDelta;\n\n\t\t// Reset segments mark\n\t\tconst numPointPairs = numPoints * numPoints;\n\t\tfor ( let i = 0; i < numPointPairs; i ++ ) this.segments[ i ] = false;\n\n\t\tconst p0 = this.tempVector3_P0;\n\t\tconst p1 = this.tempVector3_P1;\n\t\tconst n0 = this.tempVector3_N0;\n\t\tconst n1 = this.tempVector3_N1;\n\n\t\t// Iterate through the faces to mark edges shared by coplanar faces\n\t\tfor ( let i = 0; i < numFaces - 1; i ++ ) {\n\n\t\t\tconst a1 = getVertexIndex( i, 0 );\n\t\t\tconst b1 = getVertexIndex( i, 1 );\n\t\t\tconst c1 = getVertexIndex( i, 2 );\n\n\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\tn0.set( normals[ a1 ], normals[ a1 ] + 1, normals[ a1 ] + 2 );\n\n\t\t\tfor ( let j = i + 1; j < numFaces; j ++ ) {\n\n\t\t\t\tconst a2 = getVertexIndex( j, 0 );\n\t\t\t\tconst b2 = getVertexIndex( j, 1 );\n\t\t\t\tconst c2 = getVertexIndex( j, 2 );\n\n\t\t\t\t// Assuming all 3 vertices have the same normal\n\t\t\t\tn1.set( normals[ a2 ], normals[ a2 ] + 1, normals[ a2 ] + 2 );\n\n\t\t\t\tconst coplanar = 1 - n0.dot( n1 ) < delta;\n\n\t\t\t\tif ( coplanar ) {\n\n\t\t\t\t\tif ( a1 === a2 || a1 === b2 || a1 === c2 ) {\n\n\t\t\t\t\t\tif ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + b1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ b1 * numPoints + a1 ] = true;\n\n\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\tthis.segments[ c1 * numPoints + a1 ] = true;\n\t\t\t\t\t\t\tthis.segments[ a1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\telse if ( b1 === a2 || b1 === b2 || b1 === c2 ) {\n\n\t\t\t\t\t\tthis.segments[ c1 * numPoints + b1 ] = true;\n\t\t\t\t\t\tthis.segments[ b1 * numPoints + c1 ] = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Transform the plane to object local space\n\t\tconst localPlane = this.tempPlane_Cut;\n\t\tobject.updateMatrix();\n\t\tConvexObjectBreaker.transformPlaneToLocalSpace( plane, object.matrix, localPlane );\n\n\t\t// Iterate through the faces adding points to both pieces\n\t\tfor ( let i = 0; i < numFaces; i ++ ) {\n\n\t\t\tconst va = getVertexIndex( i, 0 );\n\t\t\tconst vb = getVertexIndex( i, 1 );\n\t\t\tconst vc = getVertexIndex( i, 2 );\n\n\t\t\tfor ( let segment = 0; segment < 3; segment ++ ) {\n\n\t\t\t\tconst i0 = segment === 0 ? va : ( segment === 1 ? vb : vc );\n\t\t\t\tconst i1 = segment === 0 ? vb : ( segment === 1 ? vc : va );\n\n\t\t\t\tconst segmentState = this.segments[ i0 * numPoints + i1 ];\n\n\t\t\t\tif ( segmentState ) continue; // The segment already has been processed in another face\n\n\t\t\t\t// Mark segment as processed (also inverted segment)\n\t\t\t\tthis.segments[ i0 * numPoints + i1 ] = true;\n\t\t\t\tthis.segments[ i1 * numPoints + i0 ] = true;\n\n\t\t\t\tp0.set( coords[ 3 * i0 ], coords[ 3 * i0 + 1 ], coords[ 3 * i0 + 2 ] );\n\t\t\t\tp1.set( coords[ 3 * i1 ], coords[ 3 * i1 + 1 ], coords[ 3 * i1 + 2 ] );\n\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\tlet mark0 = 0;\n\n\t\t\t\tlet d = localPlane.distanceToPoint( p0 );\n\n\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\tmark0 = 2;\n\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\tmark0 = 1;\n\t\t\t\t\tpoints1.push( p0.clone() );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmark0 = 3;\n\t\t\t\t\tpoints1.push( p0.clone() );\n\t\t\t\t\tpoints2.push( p0.clone() );\n\n\t\t\t\t}\n\n\t\t\t\t// mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\t\t\t\tlet mark1 = 0;\n\n\t\t\t\td = localPlane.distanceToPoint( p1 );\n\n\t\t\t\tif ( d > delta ) {\n\n\t\t\t\t\tmark1 = 2;\n\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t} else if ( d < - delta ) {\n\n\t\t\t\t\tmark1 = 1;\n\t\t\t\t\tpoints1.push( p1.clone() );\n\n\t\t\t\t}\telse {\n\n\t\t\t\t\tmark1 = 3;\n\t\t\t\t\tpoints1.push( p1.clone() );\n\t\t\t\t\tpoints2.push( p1.clone() );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ( mark0 === 1 && mark1 === 2 ) || ( mark0 === 2 && mark1 === 1 ) ) {\n\n\t\t\t\t\t// Intersection of segment with the plane\n\n\t\t\t\t\tthis.tempLine1.start.copy( p0 );\n\t\t\t\t\tthis.tempLine1.end.copy( p1 );\n\n\t\t\t\t\tlet intersection = new Vector3();\n\t\t\t\t\tintersection = localPlane.intersectLine( this.tempLine1, intersection );\n\n\t\t\t\t\tif ( intersection === null ) {\n\n\t\t\t\t\t\t// Shouldn't happen\n\t\t\t\t\t\tconsole.error( 'Internal error: segment does not intersect plane.' );\n\t\t\t\t\t\toutput.segmentedObject1 = null;\n\t\t\t\t\t\toutput.segmentedObject2 = null;\n\t\t\t\t\t\treturn 0;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpoints1.push( intersection );\n\t\t\t\t\tpoints2.push( intersection.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Calculate debris mass (very fast and imprecise):\n\t\tconst newMass = object.userData.mass * 0.5;\n\n\t\t// Calculate debris Center of Mass (again fast and imprecise)\n\t\tthis.tempCM1.set( 0, 0, 0 );\n\t\tlet radius1 = 0;\n\t\tconst numPoints1 = points1.length;\n\n\t\tif ( numPoints1 > 0 ) {\n\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) this.tempCM1.add( points1[ i ] );\n\n\t\t\tthis.tempCM1.divideScalar( numPoints1 );\n\t\t\tfor ( let i = 0; i < numPoints1; i ++ ) {\n\n\t\t\t\tconst p = points1[ i ];\n\t\t\t\tp.sub( this.tempCM1 );\n\t\t\t\tradius1 = Math.max( radius1, p.x, p.y, p.z );\n\n\t\t\t}\n\n\t\t\tthis.tempCM1.add( object.position );\n\n\t\t}\n\n\t\tthis.tempCM2.set( 0, 0, 0 );\n\t\tlet radius2 = 0;\n\t\tconst numPoints2 = points2.length;\n\t\tif ( numPoints2 > 0 ) {\n\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) this.tempCM2.add( points2[ i ] );\n\n\t\t\tthis.tempCM2.divideScalar( numPoints2 );\n\t\t\tfor ( let i = 0; i < numPoints2; i ++ ) {\n\n\t\t\t\tconst p = points2[ i ];\n\t\t\t\tp.sub( this.tempCM2 );\n\t\t\t\tradius2 = Math.max( radius2, p.x, p.y, p.z );\n\n\t\t\t}\n\n\t\t\tthis.tempCM2.add( object.position );\n\n\t\t}\n\n\t\tlet object1 = null;\n\t\tlet object2 = null;\n\n\t\tlet numObjects = 0;\n\n\t\tif ( numPoints1 > 4 ) {\n\n\t\t\tobject1 = new Mesh( new ConvexGeometry( points1 ), object.material );\n\t\t\tobject1.position.copy( this.tempCM1 );\n\t\t\tobject1.quaternion.copy( object.quaternion );\n\n\t\t\tthis.prepareBreakableObject( object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak );\n\n\t\t\tnumObjects ++;\n\n\t\t}\n\n\t\tif ( numPoints2 > 4 ) {\n\n\t\t\tobject2 = new Mesh( new ConvexGeometry( points2 ), object.material );\n\t\t\tobject2.position.copy( this.tempCM2 );\n\t\t\tobject2.quaternion.copy( object.quaternion );\n\n\t\t\tthis.prepareBreakableObject( object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak );\n\n\t\t\tnumObjects ++;\n\n\t\t}\n\n\t\toutput.object1 = object1;\n\t\toutput.object2 = object2;\n\n\t\treturn numObjects;\n\n\t}\n\n\tstatic transformFreeVector( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\n\t\tv.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\n\t\tv.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformFreeVectorInverse( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a free vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z;\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z;\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z;\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformTiedVectorInverse( v, m ) {\n\n\t\t// input:\n\t\t// vector interpreted as a tied (ordinary) vector\n\t\t// THREE.Matrix4 orthogonal matrix (matrix without scale)\n\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst e = m.elements;\n\n\t\tv.x = e[ 0 ] * x + e[ 1 ] * y + e[ 2 ] * z - e[ 12 ];\n\t\tv.y = e[ 4 ] * x + e[ 5 ] * y + e[ 6 ] * z - e[ 13 ];\n\t\tv.z = e[ 8 ] * x + e[ 9 ] * y + e[ 10 ] * z - e[ 14 ];\n\n\t\treturn v;\n\n\t}\n\n\tstatic transformPlaneToLocalSpace( plane, m, resultPlane ) {\n\n\t\tresultPlane.normal.copy( plane.normal );\n\t\tresultPlane.constant = plane.constant;\n\n\t\tconst referencePoint = ConvexObjectBreaker.transformTiedVectorInverse( plane.coplanarPoint( _v1 ), m );\n\n\t\tConvexObjectBreaker.transformFreeVectorInverse( resultPlane.normal, m );\n\n\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\n\t\tresultPlane.constant = - referencePoint.dot( resultPlane.normal );\n\n\t}\n\n}\n\nexport { ConvexObjectBreaker };\n"],
  "mappings": "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",
  "names": ["_v1"]
}
